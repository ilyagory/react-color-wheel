{"ast":null,"code":"import _slicedToArray from \"/Users/tay/Desktop/codey/react-colour-wheel/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/tay/Desktop/codey/react-colour-wheel/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tay/Desktop/codey/react-colour-wheel/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/tay/Desktop/codey/react-colour-wheel/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/tay/Desktop/codey/react-colour-wheel/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/tay/Desktop/codey/react-colour-wheel/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/tay/Desktop/codey/react-colour-wheel/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nvar _jsxFileName = \"/Users/tay/Desktop/codey/react-colour-wheel/src/components/colourWheel/ColourWheel.js\";\n// NOTES:\n// -- Array-destructuring assignment won't work w vanilla ie11; needs babel-polyfill lol\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types'; // Utils:\n\nimport { colourToRgbObj, getEffectiveRadius, calculateBounds, produceRgbShades, convertObjToString } from '../../utils/utils';\nimport hexStrings from '../../utils/hexStrings'; // Global-vars:\n\nvar fullCircle = 2 * Math.PI;\nvar quarterCircle = fullCircle / 4;\n\nvar ColourWheel =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(ColourWheel, _Component);\n\n  function ColourWheel() {\n    var _this;\n\n    _classCallCheck(this, ColourWheel);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ColourWheel).call(this));\n    _this.state = {\n      rgb: null,\n      innerWheelOpen: false,\n      centerCircleOpen: false // Initialised just before the DOM has loaded; after constructor().\n\n    };\n    _this.outerWheelBounds = null;\n    _this.innerWheelBounds = null;\n    _this.centerCircleBounds = null;\n    _this.outerWheelRadius = null;\n    _this.innerWheelRadius = null;\n    _this.centerCircleRadius = null;\n    _this.firstSpacerRadius = null;\n    _this.secondSpacerRadius = null; // Initialised once the DOM has loaded.\n\n    _this.canvasEl = null;\n    _this.ctx = null; // Bindings:\n\n    _this.onCanvasHover = _this.onCanvasHover.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.onCanvasClick = _this.onCanvasClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  } // MARK - Common:\n\n\n  _createClass(ColourWheel, [{\n    key: \"getRelativeMousePos\",\n    value: function getRelativeMousePos(clientX, clientY) {\n      var radius = this.props.radius;\n      var canvasPos = this.canvasEl.getBoundingClientRect();\n      var h = radius * 2;\n      var w = radius * 2; // evtPos relative to our canvas.\n\n      var onCanvas = {\n        x: clientX - canvasPos.left,\n        y: clientY - canvasPos.top // e is our mouse-position relative to the center of the canvasEl; using pythag\n\n      };\n      var fromCenter = Math.sqrt((onCanvas.x - w / 2) * (onCanvas.x - w / 2) + (onCanvas.y - h / 2) * (onCanvas.y - h / 2)); // This returns an object in which we have both mouse-pos relative to the canvas, as well as the true-middle.\n\n      return {\n        fromCenter: fromCenter,\n        onCanvas: onCanvas\n      };\n    }\n  }, {\n    key: \"initCanvas\",\n    value: function initCanvas() {\n      var radius = this.props.radius;\n      var width = radius * 2;\n      var height = radius * 2;\n      this.ctx.clearRect(0, 0, width, height);\n      this.drawOuterWheel();\n      this.drawSpacers();\n    } // MARK - Life-cycle methods:\n\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      var _this$props = this.props,\n          radius = _this$props.radius,\n          lineWidth = _this$props.lineWidth,\n          padding = _this$props.padding; // Setting effective radii:\n\n      this.outerWheelRadius = radius;\n      this.innerWheelRadius = this.outerWheelRadius - lineWidth - padding;\n      this.centerCircleRadius = this.innerWheelRadius - lineWidth - padding;\n      this.firstSpacerRadius = this.outerWheelRadius - lineWidth; // NOTE: effectiveRadius will take into account padding as lineWidth.\n\n      this.secondSpacerRadius = this.innerWheelRadius - lineWidth; // Defining our bounds-objects, exposes a .inside(e) -> boolean method:\n\n      this.outerWheelBounds = calculateBounds(radius - lineWidth, radius);\n      this.innerWheelBounds = calculateBounds(this.innerWheelRadius - lineWidth, this.innerWheelRadius);\n      this.centerCircleBounds = calculateBounds(0, this.centerCircleRadius);\n      this.firstSpacerBounds = calculateBounds(this.firstSpacerRadius - padding, this.firstSpacerRadius);\n      this.secondSpacerBounds = calculateBounds(this.secondSpacerRadius - padding, this.secondSpacerRadius);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      // Giving this context to our parent component.\n      this.props.onRef(this); // Initialising our canvas & context objs.\n\n      this.canvasEl = document.getElementById('colour-picker');\n      this.ctx = this.canvasEl.getContext('2d');\n\n      if (this.props.preset) {\n        var rgb = colourToRgbObj(this.props.presetColour);\n        this.setState({\n          rgb: rgb\n        }, function () {\n          _this2.drawOuterWheel();\n\n          _this2.drawInnerWheel();\n\n          _this2.drawCenterCircle();\n\n          _this2.drawSpacers();\n        });\n      } else {\n        this.drawOuterWheel();\n        this.drawSpacers();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.props.onRef(undefined);\n    } // MARK - mouse-events:\n\n  }, {\n    key: \"onCanvasHover\",\n    value: function onCanvasHover(_ref) {\n      var clientX = _ref.clientX,\n          clientY = _ref.clientY;\n      var evt = this.getRelativeMousePos(clientX, clientY); // Cases for mouse-location:\n\n      if (this.outerWheelBounds.inside(evt.fromCenter)) {\n        this.canvasEl.style.cursor = 'crosshair';\n      } else if (this.innerWheelBounds.inside(evt.fromCenter) && this.state.innerWheelOpen) {\n        this.canvasEl.style.cursor = 'crosshair';\n      } else if (this.centerCircleBounds.inside(evt.fromCenter) && this.state.centerCircleOpen) {\n        // TODO: Have it clear on click?\n        this.canvasEl.style.cursor = 'pointer';\n      } else {\n        this.canvasEl.style.cursor = 'auto';\n      }\n    }\n  }, {\n    key: \"onCanvasClick\",\n    value: function onCanvasClick(_ref2) {\n      var clientX = _ref2.clientX,\n          clientY = _ref2.clientY;\n      var evt = this.getRelativeMousePos(clientX, clientY); // Cases for click-events:\n\n      if (this.outerWheelBounds.inside(evt.fromCenter)) {\n        this.outerWheelClicked(evt.onCanvas);\n      } else if (this.innerWheelBounds.inside(evt.fromCenter) && this.state.innerWheelOpen) {\n        this.innerWheelClicked(evt.onCanvas);\n      }\n    } // MARK - Clicks & action methods:\n\n  }, {\n    key: \"outerWheelClicked\",\n    value: function outerWheelClicked(evtPos) {\n      var _this3 = this;\n\n      // returns an rgba array of the pixel-clicked.\n      var rgbaArr = this.ctx.getImageData(evtPos.x, evtPos.y, 1, 1).data;\n\n      var _rgbaArr = _slicedToArray(rgbaArr, 3),\n          r = _rgbaArr[0],\n          g = _rgbaArr[1],\n          b = _rgbaArr[2];\n\n      var rgb = {\n        r: r,\n        g: g,\n        b: b // Whether the user wants rgb-strings or rgb objects returned.\n\n      };\n      var rgbArg = convertObjToString(rgb); // TODO: Let user set different return values in props; e.g. rbg obj, string, etc.\n\n      this.props.onColourSelected(rgbArg);\n      this.setState({\n        rgb: rgb,\n        innerWheelOpen: true,\n        centerCircleOpen: true\n      }, function () {\n        _this3.drawInnerWheel();\n\n        _this3.drawCenterCircle();\n      });\n    }\n  }, {\n    key: \"innerWheelClicked\",\n    value: function innerWheelClicked(evtPos) {\n      var _this4 = this;\n\n      var rgbaArr = this.ctx.getImageData(evtPos.x, evtPos.y, 1, 1).data;\n\n      var _rgbaArr2 = _slicedToArray(rgbaArr, 3),\n          r = _rgbaArr2[0],\n          g = _rgbaArr2[1],\n          b = _rgbaArr2[2];\n\n      var rgb = {\n        r: r,\n        g: g,\n        b: b\n      };\n      var rgbArg = convertObjToString(rgb);\n      this.props.onColourSelected(rgbArg);\n      this.setState({\n        rgb: rgb,\n        centerCircleOpen: true\n      }, function () {\n        _this4.drawCenterCircle();\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this5 = this;\n\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.setState({\n        rgb: null,\n        innerWheelOpen: false,\n        centerCircleOpen: false\n      }, function () {\n        // Reset state & re-draw.\n        _this5.initCanvas();\n\n        if (callback) callback();\n      });\n    } // MARK - Drawing:\n\n  }, {\n    key: \"drawOuterWheel\",\n    value: function drawOuterWheel() {\n      var _this6 = this;\n\n      // TODO: Draw outline; separate method.\n      var _this$props2 = this.props,\n          radius = _this$props2.radius,\n          colours = _this$props2.colours,\n          lineWidth = _this$props2.lineWidth;\n      var height = radius * 2;\n      var width = radius * 2; // This value ensures that the stroke accounts for the lineWidth provided to produce an accurately represented radius.\n\n      var effectiveRadius = getEffectiveRadius(radius, lineWidth); // Converting each colour into a relative rgb-object we can iterate through.\n\n      var rgbArr = colours.map(function (colour) {\n        return colourToRgbObj(colour);\n      });\n      rgbArr.forEach(function (rgb, i) {\n        _this6.ctx.beginPath(); // Creates strokes 1 / rgbArr.length of the circle circumference.\n\n\n        var startAngle = fullCircle / rgbArr.length * i;\n        var endAngle = fullCircle / rgbArr.length * (i + 1);\n\n        _this6.ctx.arc(width / 2, height / 2, effectiveRadius, startAngle, endAngle);\n\n        _this6.ctx.lineWidth = lineWidth; // This is the width of the innerWheel.\n        // Stroke-style changes based on the shade:\n\n        _this6.ctx.strokeStyle = \"rgb(\".concat(rgb.r, \", \").concat(rgb.g, \", \").concat(rgb.b, \")\");\n\n        _this6.ctx.stroke();\n\n        _this6.ctx.closePath();\n      });\n    }\n  }, {\n    key: \"drawSpacers\",\n    value: function drawSpacers() {\n      if (this.props.spacers) {\n        this.drawSpacer(this.firstSpacerRadius);\n        this.drawSpacer(this.secondSpacerRadius);\n      }\n    }\n  }, {\n    key: \"drawSpacer\",\n    value: function drawSpacer(spacerRadius) {\n      var _this$props3 = this.props,\n          radius = _this$props3.radius,\n          padding = _this$props3.padding,\n          _this$props3$spacers = _this$props3.spacers,\n          colour = _this$props3$spacers.colour,\n          shadowColour = _this$props3$spacers.shadowColour,\n          shadowBlur = _this$props3$spacers.shadowBlur;\n      var height = radius * 2;\n      var width = radius * 2;\n      var effectiveRadius = getEffectiveRadius(spacerRadius, padding);\n      this.ctx.beginPath();\n      this.ctx.arc(width / 2, height / 2, effectiveRadius, 0, fullCircle);\n      this.ctx.lineWidth = padding;\n      this.ctx.shadowColor = shadowColour;\n      this.ctx.shadowBlur = shadowBlur;\n      this.ctx.strokeStyle = colour;\n      this.ctx.stroke();\n      this.ctx.closePath(); // To reset our shadowColor for other strokes.\n\n      this.ctx.shadowColor = 'transparent';\n    }\n  }, {\n    key: \"drawInnerWheel\",\n    value: function drawInnerWheel() {\n      var animationPercentage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      // raf setup.\n      var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n      window.requestAnimationFrame = requestAnimationFrame;\n      var _this$state$rgb = this.state.rgb,\n          r = _this$state$rgb.r,\n          g = _this$state$rgb.g,\n          b = _this$state$rgb.b;\n      var _this$props4 = this.props,\n          radius = _this$props4.radius,\n          lineWidth = _this$props4.lineWidth,\n          shades = _this$props4.shades,\n          animated = _this$props4.animated;\n      var height = radius * 2;\n      var width = radius * 2;\n      var effectiveRadius = getEffectiveRadius(this.innerWheelRadius, lineWidth); // Re-initialising canvas.\n\n      this.ctx.clearRect(0, 0, width, height);\n      this.drawOuterWheel();\n      this.drawSpacers();\n      var rgbShades = produceRgbShades(r, g, b, shades); // Different functions for drawing our inner-wheel of shades.\n\n      function drawShades() {\n        var _this7 = this;\n\n        rgbShades.forEach(function (rgb, i) {\n          _this7.ctx.beginPath();\n\n          var startAngle = fullCircle / rgbShades.length * i + quarterCircle;\n          var endAngle = fullCircle / rgbShades.length * (i + 1) + 1 / 2 * Math.PI;\n\n          _this7.ctx.arc(width / 2, height / 2, effectiveRadius, startAngle, endAngle);\n\n          _this7.ctx.lineWidth = lineWidth; // This is the width of the innerWheel.\n          // Stroke style changes based on the shade:\n\n          _this7.ctx.strokeStyle = \"rgb(\".concat(rgb.r, \", \").concat(rgb.g, \", \").concat(rgb.b, \")\");\n\n          _this7.ctx.stroke();\n\n          _this7.ctx.closePath();\n        });\n      }\n\n      function animateShades() {\n        var _this8 = this;\n\n        rgbShades.forEach(function (rgb, i) {\n          _this8.ctx.beginPath();\n\n          var startAngle = fullCircle / rgbShades.length * i + quarterCircle;\n          var endAngle = fullCircle / rgbShades.length * (i + 1) + 1 / 2 * Math.PI;\n\n          _this8.ctx.arc(width / 2, height / 2, effectiveRadius, startAngle, endAngle);\n\n          _this8.ctx.lineWidth = lineWidth * animationPercentage; // This is the width of the innerWheel.\n          // Stroke style changes based on the shade:\n\n          _this8.ctx.strokeStyle = \"rgb(\".concat(rgb.r, \", \").concat(rgb.g, \", \").concat(rgb.b, \")\");\n\n          _this8.ctx.stroke();\n\n          _this8.ctx.closePath();\n        }); // TODO: Make this animation speed dynamic.\n\n        animationPercentage += 1 / 10; // i.e. 1 / x frames\n        // Essentially re-draws rgbShades.forEach until the animationPercentage reaches 1, i.e. 100%\n\n        if (animationPercentage < 1) requestAnimationFrame(animateShades);\n      }\n\n      animateShades = animateShades.bind(this);\n      drawShades = drawShades.bind(this);\n\n      if (animated) {\n        animateShades();\n      } else {\n        // TODO: Refactor into its own func.\n        drawShades();\n      }\n    }\n  }, {\n    key: \"drawCenterCircle\",\n    value: function drawCenterCircle() {\n      var rgb = this.state.rgb;\n      var radius = this.props.radius;\n      var height = radius * 2;\n      var width = radius * 2;\n      this.ctx.lineWidth = 0;\n      this.ctx.beginPath();\n      this.ctx.arc(width / 2, height / 2, this.centerCircleRadius, 0, 2 * Math.PI);\n      this.ctx.fillStyle = \"rgb(\".concat(rgb.r, \", \").concat(rgb.g, \", \").concat(rgb.b, \")\");\n      this.ctx.fill();\n      this.ctx.lineWidth = 0.1;\n      this.ctx.strokeStyle = \"rgb(\".concat(rgb.r, \", \").concat(rgb.g, \", \").concat(rgb.b, \")\");\n      this.ctx.stroke();\n      this.ctx.closePath();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props5 = this.props,\n          radius = _this$props5.radius,\n          dynamicCursor = _this$props5.dynamicCursor;\n      return dynamicCursor ? React.createElement(\"canvas\", {\n        id: \"colour-picker\",\n        onClick: this.onCanvasClick,\n        onMouseMove: this.onCanvasHover,\n        width: \"\".concat(radius * 2, \"px\"),\n        height: \"\".concat(radius * 2, \"px\"),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 368\n        },\n        __self: this\n      }) : React.createElement(\"canvas\", {\n        id: \"colour-picker\",\n        onClick: this.onCanvasClick,\n        width: \"\".concat(radius * 2, \"px\"),\n        height: \"\".concat(radius * 2, \"px\"),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 376\n        },\n        __self: this\n      });\n    }\n  }]);\n\n  return ColourWheel;\n}(Component);\n\nColourWheel.propTypes = {\n  radius: PropTypes.number.isRequired,\n  lineWidth: PropTypes.number.isRequired,\n  colours: PropTypes.array,\n  shades: PropTypes.number,\n  padding: PropTypes.number,\n  dynamicCursor: PropTypes.bool,\n  spacers: PropTypes.object,\n  onColourSelected: PropTypes.func,\n  preset: PropTypes.bool // presetColour: PropTypes.string\n\n};\nColourWheel.defaultProps = {\n  colours: hexStrings,\n  shades: 16,\n  padding: 0,\n  dynamicCursor: true,\n  preset: false,\n  animate: false\n};\nexport default ColourWheel;","map":{"version":3,"sources":["/Users/tay/Desktop/codey/react-colour-wheel/src/components/colourWheel/ColourWheel.js"],"names":["React","Component","PropTypes","colourToRgbObj","getEffectiveRadius","calculateBounds","produceRgbShades","convertObjToString","hexStrings","fullCircle","Math","PI","quarterCircle","ColourWheel","state","rgb","innerWheelOpen","centerCircleOpen","outerWheelBounds","innerWheelBounds","centerCircleBounds","outerWheelRadius","innerWheelRadius","centerCircleRadius","firstSpacerRadius","secondSpacerRadius","canvasEl","ctx","onCanvasHover","bind","onCanvasClick","clientX","clientY","radius","props","canvasPos","getBoundingClientRect","h","w","onCanvas","x","left","y","top","fromCenter","sqrt","width","height","clearRect","drawOuterWheel","drawSpacers","lineWidth","padding","firstSpacerBounds","secondSpacerBounds","onRef","document","getElementById","getContext","preset","presetColour","setState","drawInnerWheel","drawCenterCircle","undefined","evt","getRelativeMousePos","inside","style","cursor","outerWheelClicked","innerWheelClicked","evtPos","rgbaArr","getImageData","data","r","g","b","rgbArg","onColourSelected","callback","initCanvas","colours","effectiveRadius","rgbArr","map","colour","forEach","i","beginPath","startAngle","length","endAngle","arc","strokeStyle","stroke","closePath","spacers","drawSpacer","spacerRadius","shadowColour","shadowBlur","shadowColor","animationPercentage","requestAnimationFrame","window","mozRequestAnimationFrame","webkitRequestAnimationFrame","msRequestAnimationFrame","shades","animated","rgbShades","drawShades","animateShades","fillStyle","fill","dynamicCursor","propTypes","number","isRequired","array","bool","object","func","defaultProps","animate"],"mappings":"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","sourcesContent":["// NOTES:\n// -- Array-destructuring assignment won't work w vanilla ie11; needs babel-polyfill lol\n\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\n// Utils:\nimport {\n  colourToRgbObj,\n  getEffectiveRadius,\n  calculateBounds,\n  produceRgbShades,\n  convertObjToString\n} from '../../utils/utils'\nimport hexStrings from '../../utils/hexStrings'\n\n// Global-vars:\nconst fullCircle = 2 * Math.PI\nconst quarterCircle = fullCircle / 4\n\nclass ColourWheel extends Component {\n  constructor () {\n    super()\n\n    this.state = {\n      rgb: null,\n      innerWheelOpen: false,\n      centerCircleOpen: false\n    }\n\n    // Initialised just before the DOM has loaded; after constructor().\n    this.outerWheelBounds = null\n    this.innerWheelBounds = null\n    this.centerCircleBounds = null\n\n    this.outerWheelRadius = null\n    this.innerWheelRadius = null\n    this.centerCircleRadius = null\n    this.firstSpacerRadius = null\n    this.secondSpacerRadius = null\n\n    // Initialised once the DOM has loaded.\n    this.canvasEl = null\n    this.ctx = null\n\n    // Bindings:\n    this.onCanvasHover = this.onCanvasHover.bind(this)\n    this.onCanvasClick = this.onCanvasClick.bind(this)\n  }\n\n  // MARK - Common:\n  getRelativeMousePos (clientX, clientY) {\n    const { radius } = this.props\n\n    const canvasPos = this.canvasEl.getBoundingClientRect()\n    const h = radius * 2\n    const w = radius * 2\n\n    // evtPos relative to our canvas.\n    const onCanvas = {\n      x: clientX - canvasPos.left,\n      y: clientY - canvasPos.top\n    }\n\n    // e is our mouse-position relative to the center of the canvasEl; using pythag\n    const fromCenter = Math.sqrt((onCanvas.x - (w / 2)) * (onCanvas.x - (w / 2)) + (onCanvas.y - (h / 2)) * (onCanvas.y - (h / 2)))\n\n    // This returns an object in which we have both mouse-pos relative to the canvas, as well as the true-middle.\n    return {\n      fromCenter,\n      onCanvas\n    }\n  }\n\n  initCanvas () {\n    const { radius } = this.props\n\n    const width = radius * 2\n    const height = radius * 2\n\n    this.ctx.clearRect(0, 0, width, height)\n\n    this.drawOuterWheel()\n    this.drawSpacers()\n  }\n\n  // MARK - Life-cycle methods:\n  componentWillMount () {\n    const { radius, lineWidth, padding } = this.props\n\n    // Setting effective radii:\n    this.outerWheelRadius = radius\n    this.innerWheelRadius = this.outerWheelRadius - lineWidth - padding\n    this.centerCircleRadius = this.innerWheelRadius - lineWidth - padding\n    this.firstSpacerRadius = this.outerWheelRadius - lineWidth // NOTE: effectiveRadius will take into account padding as lineWidth.\n    this.secondSpacerRadius = this.innerWheelRadius - lineWidth\n\n    // Defining our bounds-objects, exposes a .inside(e) -> boolean method:\n    this.outerWheelBounds = calculateBounds(radius - lineWidth, radius)\n    this.innerWheelBounds = calculateBounds(this.innerWheelRadius - lineWidth, this.innerWheelRadius)\n    this.centerCircleBounds = calculateBounds(0, this.centerCircleRadius)\n    this.firstSpacerBounds = calculateBounds(this.firstSpacerRadius - padding, this.firstSpacerRadius)\n    this.secondSpacerBounds = calculateBounds(this.secondSpacerRadius - padding, this.secondSpacerRadius)\n  }\n\n  componentDidMount () {\n    // Giving this context to our parent component.\n    this.props.onRef(this)\n\n    // Initialising our canvas & context objs.\n    this.canvasEl = document.getElementById('colour-picker')\n    this.ctx = this.canvasEl.getContext('2d')\n\n    if (this.props.preset) {\n      const rgb = colourToRgbObj(this.props.presetColour)\n\n      this.setState({ rgb }, () => {\n        this.drawOuterWheel()\n        this.drawInnerWheel()\n        this.drawCenterCircle()\n        this.drawSpacers()\n      })\n    } else {\n      this.drawOuterWheel()\n      this.drawSpacers()\n    }\n  }\n\n  componentWillUnmount () {\n    this.props.onRef(undefined)\n  }\n\n  // MARK - mouse-events:\n  onCanvasHover ({ clientX, clientY }) {\n    const evt = this.getRelativeMousePos(clientX, clientY)\n\n    // Cases for mouse-location:\n    if (this.outerWheelBounds.inside(evt.fromCenter)) {\n      this.canvasEl.style.cursor = 'crosshair'\n    } else if (this.innerWheelBounds.inside(evt.fromCenter) && this.state.innerWheelOpen) {\n      this.canvasEl.style.cursor = 'crosshair'\n    } else if (this.centerCircleBounds.inside(evt.fromCenter) && this.state.centerCircleOpen) { // TODO: Have it clear on click?\n      this.canvasEl.style.cursor = 'pointer'\n    } else {\n      this.canvasEl.style.cursor = 'auto'\n    }\n  }\n\n  onCanvasClick ({ clientX, clientY }) {\n    const evt = this.getRelativeMousePos(clientX, clientY)\n\n    // Cases for click-events:\n    if (this.outerWheelBounds.inside(evt.fromCenter)) {\n      this.outerWheelClicked(evt.onCanvas)\n    } else if (this.innerWheelBounds.inside(evt.fromCenter) && this.state.innerWheelOpen) {\n      this.innerWheelClicked(evt.onCanvas)\n    }\n  }\n\n  // MARK - Clicks & action methods:\n  outerWheelClicked (evtPos) {\n    // returns an rgba array of the pixel-clicked.\n    const rgbaArr = this.ctx.getImageData(evtPos.x, evtPos.y, 1, 1).data\n    const [r, g, b] = rgbaArr\n\n    const rgb = { r, g, b }\n\n    // Whether the user wants rgb-strings or rgb objects returned.\n    const rgbArg = convertObjToString(rgb) // TODO: Let user set different return values in props; e.g. rbg obj, string, etc.\n\n    this.props.onColourSelected(rgbArg)\n\n    this.setState({\n      rgb,\n      innerWheelOpen: true,\n      centerCircleOpen: true\n    }, () => {\n      this.drawInnerWheel()\n      this.drawCenterCircle()\n    })\n  }\n\n  innerWheelClicked (evtPos) {\n    const rgbaArr = this.ctx.getImageData(evtPos.x, evtPos.y, 1, 1).data\n    const [r, g, b] = rgbaArr\n\n    const rgb = { r, g, b }\n\n    const rgbArg = convertObjToString(rgb)\n\n    this.props.onColourSelected(rgbArg)\n\n    this.setState({\n      rgb,\n      centerCircleOpen: true\n    }, () => {\n      this.drawCenterCircle()\n    })\n  }\n\n  clear (callback = false) {\n    this.setState({\n      rgb: null,\n      innerWheelOpen: false,\n      centerCircleOpen: false\n    }, () => {\n      // Reset state & re-draw.\n      this.initCanvas()\n      if (callback) callback()\n    })\n  }\n\n  // MARK - Drawing:\n  drawOuterWheel () {\n    // TODO: Draw outline; separate method.\n    const { radius, colours, lineWidth } = this.props\n    const height = radius * 2\n    const width = radius * 2\n\n    // This value ensures that the stroke accounts for the lineWidth provided to produce an accurately represented radius.\n    const effectiveRadius = getEffectiveRadius(radius, lineWidth)\n\n    // Converting each colour into a relative rgb-object we can iterate through.\n    const rgbArr = colours.map(colour => colourToRgbObj(colour))\n\n    rgbArr.forEach((rgb, i) => {\n      this.ctx.beginPath()\n\n      // Creates strokes 1 / rgbArr.length of the circle circumference.\n      const startAngle = (fullCircle / rgbArr.length) * i\n      const endAngle = (fullCircle / rgbArr.length) * (i + 1)\n\n      this.ctx.arc(width / 2, height / 2, effectiveRadius, startAngle, endAngle)\n      this.ctx.lineWidth = lineWidth // This is the width of the innerWheel.\n\n      // Stroke-style changes based on the shade:\n      this.ctx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n      this.ctx.stroke()\n      this.ctx.closePath()\n    })\n  }\n\n  drawSpacers () {\n    if (this.props.spacers) {\n      this.drawSpacer(this.firstSpacerRadius)\n      this.drawSpacer(this.secondSpacerRadius)\n    }\n  }\n\n  drawSpacer (spacerRadius) {\n    const { radius, padding, spacers: { colour, shadowColour, shadowBlur } } = this.props\n\n    const height = radius * 2\n    const width = radius * 2\n\n    const effectiveRadius = getEffectiveRadius(spacerRadius, padding)\n\n    this.ctx.beginPath()\n\n    this.ctx.arc(width / 2, height / 2, effectiveRadius, 0, fullCircle)\n    this.ctx.lineWidth = padding\n\n    this.ctx.shadowColor = shadowColour\n    this.ctx.shadowBlur = shadowBlur\n    this.ctx.strokeStyle = colour\n    this.ctx.stroke()\n    this.ctx.closePath()\n\n    // To reset our shadowColor for other strokes.\n    this.ctx.shadowColor = 'transparent'\n  }\n\n  drawInnerWheel (animationPercentage = 0) {\n    // raf setup.\n    let requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame\n    window.requestAnimationFrame = requestAnimationFrame\n\n    const { rgb: { r, g, b } } = this.state\n    const { radius, lineWidth, shades, animated } = this.props\n\n    const height = radius * 2\n    const width = radius * 2\n\n    const effectiveRadius = getEffectiveRadius(this.innerWheelRadius, lineWidth)\n\n    // Re-initialising canvas.\n    this.ctx.clearRect(0, 0, width, height)\n\n    this.drawOuterWheel()\n    this.drawSpacers()\n\n    const rgbShades = produceRgbShades(r, g, b, shades)\n\n    // Different functions for drawing our inner-wheel of shades.\n    function drawShades () {\n      rgbShades.forEach((rgb, i) => {\n        this.ctx.beginPath()\n\n        const startAngle = ((fullCircle / rgbShades.length) * i) + quarterCircle\n        const endAngle = ((fullCircle / rgbShades.length) * (i + 1)) + (1 / 2) * Math.PI\n\n        this.ctx.arc(width / 2, height / 2, effectiveRadius, startAngle, endAngle)\n        this.ctx.lineWidth = lineWidth // This is the width of the innerWheel.\n\n        // Stroke style changes based on the shade:\n        this.ctx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n        this.ctx.stroke()\n        this.ctx.closePath()\n      })\n    }\n\n    function animateShades () {\n      rgbShades.forEach((rgb, i) => {\n        this.ctx.beginPath()\n\n        const startAngle = ((fullCircle / rgbShades.length) * i) + quarterCircle\n        const endAngle = ((fullCircle / rgbShades.length) * (i + 1)) + (1 / 2) * Math.PI\n\n        this.ctx.arc(width / 2, height / 2, effectiveRadius, startAngle, endAngle)\n        this.ctx.lineWidth = lineWidth * animationPercentage // This is the width of the innerWheel.\n\n        // Stroke style changes based on the shade:\n        this.ctx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n        this.ctx.stroke()\n        this.ctx.closePath()\n      })\n\n      // TODO: Make this animation speed dynamic.\n      animationPercentage += (1 / 10) // i.e. 1 / x frames\n\n      // Essentially re-draws rgbShades.forEach until the animationPercentage reaches 1, i.e. 100%\n      if (animationPercentage < 1) requestAnimationFrame(animateShades)\n    }\n\n    animateShades = animateShades.bind(this)\n    drawShades = drawShades.bind(this)\n\n    if (animated) {\n      animateShades()\n    } else { // TODO: Refactor into its own func.\n      drawShades()\n    }\n  }\n\n  drawCenterCircle () {\n    const { rgb } = this.state\n    const { radius } = this.props\n\n    const height = radius * 2\n    const width = radius * 2\n    this.ctx.lineWidth = 0\n\n    this.ctx.beginPath()\n    this.ctx.arc(width / 2, height / 2, this.centerCircleRadius, 0, 2 * Math.PI)\n    this.ctx.fillStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n    this.ctx.fill()\n    this.ctx.lineWidth = 0.1\n    this.ctx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`\n    this.ctx.stroke()\n    this.ctx.closePath()\n  }\n\n  render () {\n    const { radius, dynamicCursor } = this.props\n\n    return (\n      dynamicCursor ? (\n        <canvas\n          id='colour-picker'\n          onClick={this.onCanvasClick}\n          onMouseMove={this.onCanvasHover}\n          width={`${radius * 2}px`}\n          height={`${radius * 2}px`}\n        />\n      ) : (\n        <canvas\n          id='colour-picker'\n          onClick={this.onCanvasClick}\n          width={`${radius * 2}px`}\n          height={`${radius * 2}px`}\n        />\n      )\n    )\n  }\n}\n\nColourWheel.propTypes = {\n  radius: PropTypes.number.isRequired,\n  lineWidth: PropTypes.number.isRequired,\n  colours: PropTypes.array,\n  shades: PropTypes.number,\n  padding: PropTypes.number,\n  dynamicCursor: PropTypes.bool,\n  spacers: PropTypes.object,\n  onColourSelected: PropTypes.func,\n  preset: PropTypes.bool\n  // presetColour: PropTypes.string\n}\n\nColourWheel.defaultProps = {\n  colours: hexStrings,\n  shades: 16,\n  padding: 0,\n  dynamicCursor: true,\n  preset: false,\n  animate: false\n}\n\nexport default ColourWheel\n"]},"metadata":{},"sourceType":"module"}